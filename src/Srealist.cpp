/*
 * Cstress Copyright 2013 Sergi Álvarez Triviño

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include "Scommon.h"

// #define CDEBUG(text, arg) printf(text, arg) // uncomment for debugging purposes
#define handle_error_en(en, msg) \
               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

using namespace std;

struct thread_info_real {    		
           pthread_t 	thread_id;       
           int       	thread_num, sockfd, portno, n, j,  execution_mode, mbytes, k_chunks, th_delay, i; // th_delay: time that ths wait...
           float 	t;									// ...at the end of every it.
	   char 	read_buffer[256];
	   sockaddr_in 	serv_addr;
	   fd_set 	input;		
	   fd_set 	output;		
	   timeval 	timeout;
	   hostent 	*server;
	   char* 	expected_answer;
	   char* delimiter;
	   char 	*send_buffer;		   
       };
       
thread_info_real *tinfo_real;     

void thread_real_init() { 	
	tinfo_real = (thread_info_real * )  calloc(nthreads,(sizeof(thread_info_real)+expected_answer.size()+1+m_bytes));	
}	

//------------------------------
// CHRONO
void start_chrono_real(int i) {
     pthread_t 		cht_id;
     void * 		(*func_pointer)(void *);
     func_pointer = 	chrono_handler_real;
     int* p = 		&i;
     pthread_create(&cht_id, NULL, func_pointer,(void *) &p );	// if returns EAGAIN = max. number threads
     pthread_detach(cht_id);		
     return;									
}

void * chrono_handler_real(void* arg) {
     sleep(t);					// sleeps the time given by the user 
     printf("TIME UP!!!\n\n");
     kill = true;				
     sleep(2);
     free(tinfo_real);				
     int *p_id = (int*) arg;
     pthread_cond_signal(&thread_end_cond);	// signal to the main thread
     pthread_exit((void*) p_id);		
     return 0;
}
//-----------------------------

void thread_make_real(int i, int delay)			// thread creation
{
        void * (*func_pointer)(void*);	
	func_pointer = thread_main_real;			
	
	tinfo_real[i].th_delay = 	delay;			// generated by the calling func.
	tinfo_real[i].thread_id = 	(pthread_t)i;			
	tinfo_real[i].thread_num =	i;
	#ifdef CDEBUG
		printf("thread %i. Delay = %i\n",tinfo_real[i].thread_num,  tinfo_real[i].th_delay);
        #endif  
	tinfo_real[i].portno =		portno;
	tinfo_real[i].k_chunks = 	k_chunks;
	tinfo_real[i].mbytes = 		m_bytes;
	tinfo_real[i].send_buffer = 	new char[m_bytes];	
	tinfo_real[i].execution_mode =	execution_mode;
	tinfo_real[i].server =		server;
	tinfo_real[i].t = 		t;	
	tinfo_real[i].expected_answer =  new char[expected_answer.size()+1];
	strcpy( tinfo_real[i].expected_answer, expected_answer.c_str());
	tinfo_real[i].delimiter = new char[delimiter.size()];
	strcpy( tinfo_real[i].delimiter, delimiter.c_str());
	
	#ifdef CDEBUG
		if(i==0) printf("The size of the array of structs is: %i \n", sizeof(tinfo_real));
	#endif	
	pthread_create(&tinfo_real[i].thread_id,NULL, func_pointer, (void *) &tinfo_real[i] );	
	// pthread_detach(tinfo_real[i].thread_id);	 
	return;									
}

//-------------------------------------------

void * thread_main_real(void *arg)						
{
     pthread_detach(pthread_self());
     thread_info_real *private_tinfo_real;					
     private_tinfo_real = (thread_info_real *) arg;				
     	
      #ifdef CDEBUG
		printf("thread %i starting\n",private_tinfo_real->thread_num);
      #endif   
         
while(1) {			
		if (kill) {						// time up
		    pthread_mutex_lock(&clifd_mutex);
		    nthreads--;		
		    pthread_mutex_unlock(&clifd_mutex);
		    #ifdef CDEBUG
			cout<< "Thread " << private_tinfo_real->thread_num << "  is being killed." <<endl ;
		    #endif
		    pthread_exit(&tinfo_real[private_tinfo_real->thread_num].thread_id);		
		}
	  	  
	  // Connection to host
	     private_tinfo_real->sockfd = socket(AF_INET, SOCK_STREAM, 0);
	     if (private_tinfo_real->sockfd < 0) {
		  #ifdef CDEBUG
			printf("ERROR opening socket");
		  #endif
		  delete[] private_tinfo_real->expected_answer;
		  delete [] private_tinfo_real->send_buffer;											
		  pthread_mutex_lock(&clifd_mutex);	
		  close(private_tinfo_real->sockfd);						
		  conn_error++;
		  nthreads--;					
		  pthread_mutex_unlock(&clifd_mutex);
		  pthread_exit((void*) private_tinfo_real->thread_id);
	     }
	     if (private_tinfo_real->server == NULL) {
		  #ifdef CDEBUG
			fprintf(stderr,"ERROR, no such host\n");
		  #endif
		  delete[] private_tinfo_real->expected_answer;
		  delete [] private_tinfo_real->send_buffer;				
		  pthread_mutex_lock(&clifd_mutex);
		  close(private_tinfo_real->sockfd);						
		  conn_error++;
		  nthreads--;					
		  pthread_mutex_unlock(&clifd_mutex);
		  pthread_exit((void*) private_tinfo_real->thread_id);
	     }
	     bzero((char *) &(private_tinfo_real->serv_addr), sizeof(private_tinfo_real->serv_addr));
	     private_tinfo_real->serv_addr.sin_family = AF_INET;
	     bcopy((char *)(private_tinfo_real->server)->h_addr, 
		  (char *)&private_tinfo_real->serv_addr.sin_addr.s_addr,
		  private_tinfo_real->server->h_length);
	     private_tinfo_real->serv_addr.sin_port = htons(private_tinfo_real->portno);
	     
	     if (connect(private_tinfo_real->sockfd,(sockaddr *) &private_tinfo_real->serv_addr,sizeof(private_tinfo_real->serv_addr)) < 0) {
		  #ifdef CDEBUG
			printf("ERROR connecting");
		  #endif
		  delete[] private_tinfo_real->expected_answer;
		  delete [] private_tinfo_real->send_buffer;
		  pthread_mutex_lock(&clifd_mutex);
		  close(private_tinfo_real->sockfd);						
		  conn_error++;
		  nthreads--;					
		  pthread_mutex_unlock(&clifd_mutex);
		  pthread_exit((void*) private_tinfo_real->thread_id);
	     }
	     
	  // generating bytes to be sent:
	     memset( private_tinfo_real->send_buffer,'A',private_tinfo_real->mbytes);
		   
	  if (private_tinfo_real->i==0) {	// just waits on the first iteration
		  #ifdef CDEBUG
			printf("Thread %i waiting orders. Socket =  %i \n", private_tinfo_real->thread_num, private_tinfo_real->sockfd);
		  #endif  
		  
		     running_threads++;
		     if ( (pthread_cond_wait(&clifd_cond, &clifd_mutex)!=0 ) ) {
			  #ifdef CDEBUG	
				cout<< "Error pthread_cond_wait ";
			  #endif
			  delete [] private_tinfo_real->send_buffer;		
			  pthread_mutex_lock(&clifd_mutex);
			  close(private_tinfo_real->sockfd);							
			  running_threads--;
			  nthreads--;					
			  pthread_mutex_unlock(&clifd_mutex);
			  pthread_exit((void*) private_tinfo_real->thread_id);	
		     }
		     pthread_mutex_unlock(&clifd_mutex);	 
		  #ifdef CDEBUG
		     CDEBUG("Thread %i awaken. \n", private_tinfo_real->thread_num);
		  #endif
		     if (private_tinfo_real->execution_mode == 1) private_tinfo_real->k_chunks=1;	
	}	
	else {
		pthread_mutex_lock(&clifd_mutex);
		total_threads++;				
		pthread_mutex_unlock(&clifd_mutex);
		sleep(private_tinfo_real->th_delay);		// the delay comes into play
	}
	  // send loop	 	
	     for (private_tinfo_real->j=0; private_tinfo_real->j < private_tinfo_real->k_chunks; private_tinfo_real->j++) {	// n iterations = k_chunks
		  
		  private_tinfo_real->n = send(private_tinfo_real->sockfd,private_tinfo_real->send_buffer,private_tinfo_real->mbytes, MSG_NOSIGNAL); // writing buffer
		  if (private_tinfo_real->n < 0) {
		       #ifdef CDEBUG
			printf("ERROR writing bytes to socket.  Thread exits!!!\n ");
		       #endif
		       delete[] private_tinfo_real->expected_answer;
		       delete [] private_tinfo_real->send_buffer;		
		       pthread_mutex_lock(&clifd_mutex);	       			 
		       close(private_tinfo_real->sockfd);							
		       conn_error++;
		       running_threads--;
		       nthreads--;					
		       pthread_mutex_unlock(&clifd_mutex);
		       pthread_exit((void*) private_tinfo_real->thread_id);		
		  }
		  #ifdef CDEBUG
			printf("Thread %i: %i bytes sent \n", private_tinfo_real->thread_num , private_tinfo_real->mbytes );
		  #endif
	     }	  // end_for
		  
		  if (end_msg) {				               
		       FD_ZERO(&private_tinfo_real->output);						
		       FD_SET(private_tinfo_real->sockfd, &private_tinfo_real->output);			
		       private_tinfo_real->timeout.tv_sec  = 7; 
		       private_tinfo_real->timeout.tv_usec = 0;
		   
		       private_tinfo_real->n = select(private_tinfo_real->sockfd + 1, NULL , &private_tinfo_real->output, NULL, &private_tinfo_real->timeout); 
		       
		       
		       if (private_tinfo_real->n == -1) //something wrong
			    printf("Thread %i: ERROR sending delim. to server\n" , private_tinfo_real->thread_num);
			    
		       else if (private_tinfo_real->n == 0) 	//timeout
				      printf("Thread %i: TIMEOUT in send operation to server\n" , private_tinfo_real->thread_num);
				      
		       if (!FD_ISSET(private_tinfo_real->sockfd, &private_tinfo_real->output))  //again something wrong
			    printf("Thread %i: ERROR sending delim. to server\n" , private_tinfo_real->thread_num);	 
		       else {       
		// call non-blockable send
			       private_tinfo_real->n = send(private_tinfo_real->sockfd,private_tinfo_real->delimiter ,sizeof(private_tinfo_real->delimiter)-1, MSG_NOSIGNAL);	
			       if (private_tinfo_real->n < 0) {
				    #ifdef CDEBUG
					printf("ERROR writing delimiter to socket, probably the other end has gone. Thread exits!!!\n");
				    #endif
				    delete[] private_tinfo_real->expected_answer;
				    delete [] private_tinfo_real->send_buffer;		
				    pthread_mutex_lock(&clifd_mutex);	
				    close(private_tinfo_real->sockfd);						
				    conn_error++;
				    running_threads--;
				    nthreads--;					
				    pthread_mutex_unlock(&clifd_mutex);
				    pthread_exit((void*) private_tinfo_real->thread_id);		
		  }	      
		  }
	     }  
		  
		  if (ex_answer) {		// if an answer is expected 
	 // Set non-blocking read with timeout        
		       FD_ZERO(&private_tinfo_real->input);						
		       FD_SET(private_tinfo_real->sockfd, &private_tinfo_real->input);			
		       private_tinfo_real->timeout.tv_sec  = 10; 
		       private_tinfo_real->timeout.tv_usec = 0;
		       private_tinfo_real->n = select(private_tinfo_real->sockfd + 1, &private_tinfo_real->input, NULL, NULL, &private_tinfo_real->timeout); // IM: it is always + 1
		       
		       if (private_tinfo_real->n == -1) 
			    printf("Thread %i: ERROR reading from server\n" , private_tinfo_real->thread_num);
			    
		       else if (private_tinfo_real->n == 0) 	
				      printf("Thread %i: TIMEOUT in read operation from server\n" , private_tinfo_real->thread_num);
				      
		       if (!FD_ISSET(private_tinfo_real->sockfd, &private_tinfo_real->input))  
			    printf("Thread %i: ERROR reading from server\n" , private_tinfo_real->thread_num);	 
		       else {       
			    memset(private_tinfo_real->read_buffer, 0, sizeof(private_tinfo_real->read_buffer));         // clear buffer
			    private_tinfo_real->n = read(private_tinfo_real->sockfd,private_tinfo_real->read_buffer,255);		
			    if (private_tinfo_real->n < 0) {		
				 #ifdef CDEBUG
					CDEBUG("Thread %i: ERROR reading from socket\n" , private_tinfo_real->thread_num);
				 #endif
				 delete[] private_tinfo_real->expected_answer;
				 delete [] private_tinfo_real->send_buffer;							
				 pthread_mutex_lock(&clifd_mutex);
				 close(private_tinfo_real->sockfd);						
				 wrong_answers++;
				 running_threads--;
				 nthreads--;					
				 pthread_mutex_unlock(&clifd_mutex);
				 pthread_exit((void*) private_tinfo_real->thread_id);
		       }
			#ifdef CDEBUG
				CDEBUG("Received: %s\n",private_tinfo_real->read_buffer);				
			#endif
		  }
		  }
	// check answer
		pthread_mutex_lock(&clifd_mutex);	
			if ( strcmp(private_tinfo_real->read_buffer,private_tinfo_real->expected_answer)==0) correct_answers++;	
			else wrong_answers++;		
			nthreads--;		// decrease at the end of every iteration
		pthread_mutex_unlock(&clifd_mutex); 		
		close(private_tinfo_real->sockfd);						
		private_tinfo_real->i++;
	} // end_while
     
 // ending
     #ifdef CDEBUG
	CDEBUG("Thread %i closing \n", private_tinfo_real->thread_num );	
     #endif					  
     delete[] private_tinfo_real->expected_answer;
     delete[] private_tinfo_real->send_buffer;
     pthread_mutex_lock(&clifd_mutex);	
     running_threads--;
     //nthreads--;
     pthread_mutex_unlock(&clifd_mutex);
     pthread_exit((void*) private_tinfo_real->thread_id); // the thread returns		
     return 0;
}
